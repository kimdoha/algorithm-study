## 완전탐색
### 한 자리를 정하여 완전탐색
- 기본 개념
``` markdown
5개의 숫자 [1, 5, 2, 6, 8]이 주어졌을 때
이 중 단 하나의 숫자만 두 배로 해서, 인접한 숫자간의 차이의 합이 최대가 되도록 해보세요.

```
- 이 문제는 단순하게, **모든 위치의 숫자를 2배씩 해보는** 완전탐색을 진행해 볼 수 있습니다.

- **완전탐색시, 최댓값과 최솟값을 구할 때**

- **INT_MIN** = Integer.MIN_VALUE;
- **INT_MAX** = Integer.MAX_VALUE;

### 모이자
- 문제
``` markdown
    적절한 집을 선택하여 모든 사람들의 이동 거리의 합이 최소가 되도록 하는 프로그램을 작성해보세요.
```
- 1. 각 i번째 집으로 모였을 때의 합을 구해줍니다.
- 2. 가능한 거리의 합 중 최솟값을 구해줍니다.
``` java
    import java.io.*;
    import java.util.*;
    
    public class Main {
        static int n, minCost = Integer.MAX_VALUE;
        static int a[];
    
        static void solution() {
            for(int i = 0; i < n; i++) {
                int cost = 0;
    
                for(int j = 0; j < n; j++) {
                    cost += Math.abs(i - j) * a[j];
                }
    
                minCost = Math.min(minCost, cost);
            }
        }
    }
```
## 두 자리를 정하여 완전탐색
``` markdown
4개의 숫자 [1, 5, 2, 6]이 주어졌을 때
이 중 서로 다른 2개의 숫자만 두 배로 해서, 인접한 숫자간의 차이의 합이 최대가 되도록 해보세요.
```

- 이 문제는 단순하게, **2배를 해 줄 두 위치를 모두 잡아보는 완전탐색**을 진행해 볼 수 있습니다.
- 
### 괄호 쌍 만들어주기3

``` java
import java.io.*;
import java.util.*;

public class Main {
    static String ps;
    static int count = 0;

    static void solution() {
        for(int i = 0; i < ps.length(); i++) {
            if(ps.charAt(i) == ')') continue;

            for(int j = i + 1; j < ps.length(); j++) {
                if(ps.charAt(j) == ')') count++;
            }
        }
    }
}
```
