## 완전탐색
### 한 자리를 정하여 완전탐색
- 기본 개념
``` markdown
5개의 숫자 [1, 5, 2, 6, 8]이 주어졌을 때
이 중 단 하나의 숫자만 두 배로 해서, 인접한 숫자간의 차이의 합이 최대가 되도록 해보세요.

```
- 이 문제는 단순하게, **모든 위치의 숫자를 2배씩 해보는** 완전탐색을 진행해 볼 수 있습니다.

- **완전탐색시, 최댓값과 최솟값을 구할 때**
    - INT_MIN = Integer.MIN_VALUE;
    - INT_MAX = Integer.MAX_VALUE;

### 모이자
- 문제
``` markdown
    적절한 집을 선택하여 모든 사람들의 이동 거리의 합이 최소가 되도록 하는 프로그램을 작성해보세요.
```
- 1. 각 i번째 집으로 모였을 때의 합을 구해줍니다.
- 2. 가능한 거리의 합 중 최솟값을 구해줍니다.
``` java
    public class Main {
        static int n, minCost = Integer.MAX_VALUE;
        static int a[];
    
        static void solution() {
            for(int i = 0; i < n; i++) {
                int cost = 0;
    
                for(int j = 0; j < n; j++) {
                    cost += Math.abs(i - j) * a[j];
                }
    
                minCost = Math.min(minCost, cost);
            }
        }
    }
```
## 두 자리를 정하여 완전탐색
``` markdown
4개의 숫자 [1, 5, 2, 6]이 주어졌을 때
이 중 서로 다른 2개의 숫자만 두 배로 해서, 인접한 숫자간의 차이의 합이 최대가 되도록 해보세요.
```

- 이 문제는 단순하게, **2배를 해 줄 두 위치를 모두 잡아보는 완전탐색**을 진행해 볼 수 있습니다.

### 괄호 쌍 만들어주기3

``` java
public class Main {
    static String ps;
    static int count = 0;

    static void solution() {
        for(int i = 0; i < ps.length(); i++) {
            if(ps.charAt(i) == ')') continue;

            for(int j = i + 1; j < ps.length(); j++) {
                if(ps.charAt(j) == ')') count++;
            }
        }
    }
}
```

## 세 자리를 정하여 완전탐색
### 일렬로 서있는 소 2
- 문제
``` markdown
서로 다른 소의 위치를 (i, j, k)라고 했을 때, i < j < k를 만족하며 동시에 Ai ≤Aj ≤Ak를 만족하는 
서로 다른 쌍의 수를 구하는 프로그램을 작성해보세요.
```
``` java
// 모든 쌍을 다 잡아봅니다.
for(int i = 0; i < N; i++) {
    for(int j = i + 1; j < N; j++) {
        for(int k = j + 1; k < N; k++) {
            if(arr[i] <= arr[j] && arr[j] <= arr[k]) ans++;
        }
    }
}

```

## 격자 위에서의 가장 좋은 위치
<img width="444" alt="image" src="https://github.com/kimdoha/algorithm-study/assets/62235737/97ff1493-ec57-4d0a-b917-4ddd33a9f2ac">

``` java
int maxCnt = 0;
for(int i = 0; i < n; i++)
    for(int j = 0; j < n - 1; j++)
        maxCnt = Math.max(maxCnt, arr[i][j] + arr[i][j + 1]);
```

### 최고의 13인치
``` java
int maxCnt = 0;
for(int i = 0; i < N; i++) {
    for(int j = 0; j < N - 2; j++) {
        maxCnt = Math.max(maxCnt, arr[i][j] + arr[i][j + 1] + arr[i][j + 2]);
    }
}
```


### 격자 위에서의 가장 좋은 위치
<img width="436" alt="image" src="https://github.com/kimdoha/algorithm-study/assets/62235737/2ccd36e3-7f5a-4997-8fa1-e8c118708a82">

``` java
int maxCnt = 0;
for(int i = 0; i < n; i++)
    for(int j = 0; j < n - 1; j++)
        for(int k = i + 1; k < n; k++)
            for(int l = 0; l < n - 1; l++)
                maxCnt = Math.max(maxCnt, arr[i][j] + arr[i][j + 1] + arr[k][l] + arr[k][l + 1]);

System.out.println(maxCnt);
```
### 체크판위에서2
1. 이동은 항상 점프를 통해서만 가능합니다. 또, 점프 진행시 항상 현재 위치에 적혀있는 색과, 점프한 이후의 칸에 적혀있는 색이 달라야만 합니다.

2. 점프 진행시 현재 위치에서 적어도 한칸 이상 오른쪽에 있는 위치이며 동시에 현재 위치에서 적어도 한칸 이상 아래쪽에 있는 위치인 곳으로만 점프가 가능합니다.

3. 정확히 시작, 도착 지점을 제외하고 점프하며 도달한 위치가 정확히 2곳 뿐이어야 합니다.

``` java
// 이동에 성공할 수 있는 경우의 수
int count = 0;

for(int i = 1; i < R; i++) {
    for(int j = 1; j < C; j++) {
        for(int k = i + 1; k < R - 1; k++) {
            for(int l = j + 1; l < C - 1; l++) {
                if(checkBoard[0][0] != checkBoard[i][j] &&
                    checkBoard[i][j] != checkBoard[k][l] &&
                    checkBoard[k][l] != checkBoard[R - 1][C - 1]) {
                    count++;
                }
            }
        }
    }
}

```
