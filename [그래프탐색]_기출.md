## [그래프 탐색 파트] 기출문제 정리

**문제 목차**
1. [안전 영역](https://github.com/kimdoha/algorithm-study/blob/main/%5B%EA%B7%B8%EB%9E%98%ED%94%84%ED%83%90%EC%83%89%5D_%EA%B8%B0%EC%B6%9C.md#%EC%95%88%EC%A0%84-%EC%98%81%EC%97%AD)


## DFS
### 안전 영역
https://www.acmicpc.net/problem/2468

**문제 풀이**
- 2차원 배열 DFS 탐색  
- 만약 높이가 4일 때, 4보다 큰 지점들만 DFS 탐색 (= 안전한 영역 덩어리 개수)  
- 빗물 높이는 1 ~ 2차원 배열 내 가장 높은 높이

  <img width="293" alt="image" src="https://github.com/kimdoha/algorithm-study/assets/62235737/6e0586c5-61a2-40a3-9d2b-ddd208738555">


### 퇴사
- 일차원 배열 완전 탐색 - DFS 탐색(트리 전위순회 구조)
- 일차원 배열을 모두 탐색하면서 합이 S가 되는 부분수열의 개수
https://www.acmicpc.net/problem/1182

![Logic-Example](https://velog.velcdn.com/images/kimdoha/post/0f697d60-04cd-4c15-9de6-607b280a6f6b/image.png)

**✔️ 핵심 코드**
``` java
 static void dfs(int k, int sum) {
    if(k == n) {
      if(sum == target) expression++;
    } else {
      dfs(k + 1, sum + numbers[k]); 
      dfs(k + 1, sum);
    }
  }
```

**✔️ 출력**
목표하는 부분 수열의 값이 0일 때, 경우의 수와 공집합(0)을 구분하기 위해 -1을 해주어야 합니다.
``` java
    dfs(0, 0);
      
    if(target == 0) expression = expression - 1; // 공집합 제외
    System.out.println(expression);
```
